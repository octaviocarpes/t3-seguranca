import binascii
import os
import hashlib
import math
import hashlib
from Crypto.Cipher import AES

# Constants
def get_professor_B():
    return 0x129E0F471C275FD4121DAEC4B1EF66E10EB8A6E1C629E18BE23BBE850896E0211429C7DA207AB37038B09055DA22110C33A9C4FE223ACB0D0AE54BA26CADEA34A7B6617E16A1E6D3430F128549BF4AE6B3BD6EE0971ABDCA5A198FDDD965DA6A6A52BFD1919E4F81D7FDE2BA677F1EC61E8507DD8EF5BE3DE8F29C674B0824F8

def get_professor_message():
    # Last message that you sent me
    # return 0xB5C9B0472290C10E295A7CF0F3D0A38C38D42C27513DD8FF2393FF7C14A0840406A4CAD5E906B07715F82F5275B81952FA70BE82953C80AD30919C2212D4DB92D58CA33C94BFB419CA9106539B4B8B18641C0C60858B49853C479933EE7C305AA69A78875CD1A3DB6728920EF750F24A0B06A98E7F000919C2BC465A96F2DF801FDA2138926AC79CECA0D58B508210FBB39D7AD4F183C17200C702CF69B621FF24858FB5534407359CF29EE58E46044C86FFEDD7D24288432674D03A843F6D59
    return 0xD0524B92AE33A06CD274534EF974FC68FAEA6C604F00070F749CE5FDE56AB4AA092EA85DFDB92C096A190A148D46944736ED83A4C3D5221DDCD8C723CA4F4A6F2335502286E0C75B3C924C5D451016311A764F3B6C25E130A0396BB4100979297284BC48D34DDDF527E8B59AE2BB2A4B

def get_my_A():
    return 0x2d49a772eb77bd72c2d37c639c060dc63a0eb8279d7092ea775d53a91cb0e6b80cda0a6f8d67de4b7436b7ea4c3742d5ac7361982dd0fa7b44493227d9182554a7eef364c05f6c907332c2ef745414e0d61eafd47b477e9f27dc0b161dff866bcd6236865043cc1ae2e7ac53f3a1fbc7126d9c14c7ea05d2006ee5d79b9efa02

def get_my_a():
    return 450452255079695509439886716979852036450116907872377102233885698058982810646756853411475039884468329127432675572486032423219050837615390740642074483305800706462441365643220287846916185952069625972104629795860328428367241634452114592280210104217479660364720816832861215767936934493580025224579147418527816410795994963632631067182494154283575460141110018831801805859915065201898178630490914686245969135727568948998981482650138508120036626445813238459449156747817912015522971421034469011438848692604473635125373870607629189725271960594100533093400588975133582012115593516581301590649743209609617810021338572056293479634212841637143438701142425202844517815248116245309005694964678044525638605573420888567705681210060798092366687804831323992590877262208875529510783669369519453065543248217679826995975314435724109657796560297774997340512805160995934392570847751161785271872096859490154474716425783514934066200943174370041177013917600655313403113842025031761980984861765425642860220945964977166861811684534325758699597135405091777833201851359580228833657215678437209030881725825474240928834323117140296509164122076690087617897850529462945170127008847276007237717454555750419840715159050414036050751851831294196367604313824993220890387715487160104020687043875492789368596322557517136941111984858823640293646480344250130058602706618012560627960399363051131995899655191246132189565702532506323541100906382456115517605628840797792203902476351104052981220270481679599342417423367883436148071259930864666188043760691076793860349966196006637277563188628515187213918643049652355446558495626847490503581902897974452716130699171133753112555922800977773433545107262263454129957826661586252490530994856932754873860959849367995721419723759330490651500689140508980088037934859770798499706897152954214092300573497676958278450675242729540409195230042347717252522023198841027619333328511125998963881046911272123639991681861198317383604531740009070026709440504943892318036159437548274344954790928035678062007025256746900936780798381357353021730578716829798307602438915156355352462691404635513192689847818120481839747383084060624949196407710593459416784762004074612364724394346955271512370212586962743479029379823766947015566806206592993141759524726345498816249051323126074175722716299010317971186556687177676087921383041701830566797312336857294507606968522207071965065809718697525323782141639429735232786760529664383111980371693819196421342337681876214048789999328957760608317831217729837136

def get_p():
    return 0xB10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C69A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C013ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD7098488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708DF1FB2BC2E4A4371

def get_g():
    return 0xA4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507FD6406CFF14266D31266FEA1E5C41564B777E690F5504F213160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28AD662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24855E6EEB22B3B2E5

def generate_a():
    return int(binascii.hexlify(os.urandom(1024)), base=16)

def generate_module(g, a):
    p = get_p()
    return pow(g, a, p)

def revert_message(message):
    return message[::-1]

def add_padding_to_message(message):
    chunksize = 16
    len_diff = chunksize - (len(message) % chunksize)
    message += bytes([len_diff]) * len_diff

    return message

def encrypt_message(password, iv, message):
    aes = AES.new(bytes.fromhex(password), AES.MODE_CBC, iv)
    return aes.encrypt(message)

def main():
    # Part one:
    # generate my a and my A and send A to professor
    p = get_p()
    g = get_g()
    #  This is the method that generates my a
    a = generate_a()
    # This method makes the mathematic operation to generate the A
    A = generate_module(g, a)
    print('My a:\n')
    print(get_my_a())
    print('\n')

    print('Send this to professor: \n')
    # I save the generated A in this function so i can reuse it
    print(get_my_A())
    print('\n')


    # Part two:
    # Receive B from professor
    professor_B = get_professor_B()

    # Generate my V with the value received
    V = generate_module(professor_B, get_my_a())
    print('Generated V: \n')
    print(V)
    print('\n')

    # Encrypt V with SHA256
    hash = hashlib.sha256()
    # Gotta transform V to bytes because python has troubles with the signal byte transformation 
    # Had help from a classmate here
    bytes_from_V = V.to_bytes(length=math.ceil((V.bit_length()+1) / 8), byteorder='big', signed=True)
    hash.update(bytes_from_V)

    # Extract the first 16 bits from the hash to use as password
    hashed_V = hash.digest()[:16]
    # Convert the password to hex
    password = hashed_V.hex()
    print('Password: \n')
    print(password)
    print('\n')


    # Get the professor message and remove the first 2 characters from it because python places 0x in hex variables
    print('Professor message: \n')
    message = hex(get_professor_message())[2:]
    print(message)
    print('\n')

    # Transform the message into a byte array and get the initialization vector and message content
    message_in_bytes = bytes.fromhex(str(message))
    vector = message_in_bytes[:16]
    professor_message = message_in_bytes[16:]
    print('Initialization Vector: ', vector)
    print('\n')

    # Create a decryptor and Decrypt the message
    decryptor = AES.new(bytes.fromhex(password), AES.MODE_CBC, vector)
    decrypted_message = decryptor.decrypt(professor_message).decode('utf-8').strip()
    print('Message: ', decrypted_message)
    print('\n')

    # Revert the message
    reverse_message = revert_message(decrypted_message)
    print('Reverse message: ', reverse_message)
    print('\n')

    # Add padding to message
    padded_message = add_padding_to_message(bytes(reverse_message.encode('utf-8')))

    # Create a new initialization vector
    new_iv = os.urandom(16)

    # Encrypt the reverse message
    cyphered_message = encrypt_message(password, new_iv, padded_message)

    # Add initialization vector to begin and create the message
    message_to_send = new_iv.hex() + cyphered_message.hex()
    print('Message to send: ', message_to_send)

main()